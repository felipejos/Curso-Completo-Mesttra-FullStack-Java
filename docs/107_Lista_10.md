# Lista 10 - Exercícios


Estes exercícios não precisam ser entregues. Apenas tem como objetivo treinar e verificar se você coseguiu entender os conceitos envolvidos com o processamento de data.



Algoritmo 1: Data de Devolução


Desenvolva um algoritmo que:

Solicite ao usuário quantidade de dias que deseja pegar imprestado um livro.

Calcule e exiba a data de devolução do livro considerando a data atual como data de emprestimo. Exiba a data no formato dd/MM/yyyy



Algoritmo 2: Diferença Entre Dois Instantes
Faça um algoritmo que leia duas datas e horas completas no formato dd/MM/yyyy HH:mm:ss. O programa deve:

Converter as entradas em objetos LocalDateTime.

Calcular a diferença entre os dois instantes em:

dias

horas

minutos

segundos

Informar qual das duas datas é mais recente.

O objetivo é treinar LocalDateTime, Duration e comparação de datas.



Algoritmo 3: Calculadora de IdadeExata
Crie um algoritmo que solicite ao usuário sua data de nascimento no formato dd/MM/yyyy. O programa deve:

Ler a data digitada e convertê-la para um objeto LocalDate.

Calcular e exibir a idade exata do usuário em:

anos

meses

dias

Exibir também quantos dias faltam para o próximo aniversário.

O objetivo é treinar o uso de LocalDate, Period emanipulação de datas futuras.

---

## Complemento: como resolver cada algoritmo (passo a passo + exemplos)

### Regras gerais (vale pros 3)
- Use `DateTimeFormatter` para ler/exibir no formato brasileiro.
- Use `try/catch` para tratar datas inválidas (`DateTimeParseException`).
- Lembre: `LocalDate` e `LocalDateTime` são **imutáveis** (sempre reatribua).
- Para diferença:
  - `Period` → diferença entre **datas** (anos/meses/dias)
  - `Duration` → diferença entre **instantes** (horas/min/seg)

---

## Algoritmo 1: Data de Devolução (LocalDate + plusDays + formatter)

### Objetivo em português bem direto
1) Ler um inteiro (quantos dias de empréstimo).  
2) Pegar a data de hoje (data do empréstimo).  
3) Somar os dias e obter a data de devolução.  
4) Mostrar no formato `dd/MM/yyyy`.

### Pontos de atenção
- Se o usuário digitar um valor inválido (texto), trate.
- Se digitar dias negativos, você pode:
  - aceitar e gerar uma “data no passado”, ou
  - validar e mostrar mensagem (recomendado).

### Código base (exemplo completo)
    import java.time.LocalDate;
    import java.time.format.DateTimeFormatter;
    import java.util.InputMismatchException;
    import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
            Scanner teclado = new Scanner(System.in);

            try {
                System.out.print("Quantos dias deseja pegar o livro emprestado? ");
                int dias = teclado.nextInt();

                if (dias < 0) {
                    System.out.println("Quantidade de dias inválida. Digite 0 ou um número positivo.");
                    teclado.close();
                    return;
                }

                LocalDate dataEmprestimo = LocalDate.now();
                LocalDate dataDevolucao = dataEmprestimo.plusDays(dias);

                DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy");

                System.out.println("Data do empréstimo: " + dataEmprestimo.format(fmt));
                System.out.println("Data de devolução:  " + dataDevolucao.format(fmt));

            } catch (InputMismatchException e) {
                System.out.println("Entrada inválida. Digite um número inteiro (ex: 7).");
            } catch (Exception e) {
                System.out.println("Erro inesperado: " + e.getMessage());
            }

            teclado.close();
        }
    }

---

## Algoritmo 2: Diferença Entre Dois Instantes (LocalDateTime + Duration + comparação)

### Objetivo em passos
1) Ler duas strings no formato `dd/MM/yyyy HH:mm:ss`  
2) Converter as duas para `LocalDateTime` usando `DateTimeFormatter`  
3) Descobrir qual é mais recente (`isAfter`, `isBefore`, `isEqual`)  
4) Calcular diferença:
   - `Duration.between(maisAntiga, maisRecente)` (sempre nessa ordem pra ficar positivo)
5) Converter a diferença total em dias/horas/min/seg.

### Como extrair dias/horas/min/seg de Duration
- `long segundos = duration.getSeconds();`
- `dias = segundos / 86400`
- resto → horas/min/seg com módulo `%`

### Código base (exemplo completo)
    import java.time.Duration;
    import java.time.LocalDateTime;
    import java.time.format.DateTimeFormatter;
    import java.time.format.DateTimeParseException;
    import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
            Scanner teclado = new Scanner(System.in);

            DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

            try {
                System.out.print("Digite a 1ª data/hora (dd/MM/yyyy HH:mm:ss): ");
                String entrada1 = teclado.nextLine();

                System.out.print("Digite a 2ª data/hora (dd/MM/yyyy HH:mm:ss): ");
                String entrada2 = teclado.nextLine();

                LocalDateTime dt1 = LocalDateTime.parse(entrada1, fmt);
                LocalDateTime dt2 = LocalDateTime.parse(entrada2, fmt);

                LocalDateTime maisRecente;
                LocalDateTime maisAntiga;

                if (dt1.isAfter(dt2)) {
                    maisRecente = dt1;
                    maisAntiga = dt2;
                    System.out.println("\nA 1ª data é mais recente.");
                } else if (dt2.isAfter(dt1)) {
                    maisRecente = dt2;
                    maisAntiga = dt1;
                    System.out.println("\nA 2ª data é mais recente.");
                } else {
                    maisRecente = dt1;
                    maisAntiga = dt2;
                    System.out.println("\nAs duas datas são iguais.");
                }

                Duration diff = Duration.between(maisAntiga, maisRecente);
                long totalSegundos = diff.getSeconds();

                long dias = totalSegundos / 86400;
                long resto = totalSegundos % 86400;

                long horas = resto / 3600;
                resto = resto % 3600;

                long minutos = resto / 60;
                long segundos = resto % 60;

                System.out.println("Diferença entre os instantes:");
                System.out.println("Dias: " + dias);
                System.out.println("Horas: " + horas);
                System.out.println("Minutos: " + minutos);
                System.out.println("Segundos: " + segundos);

            } catch (DateTimeParseException e) {
                System.out.println("Formato inválido. Use exatamente: dd/MM/yyyy HH:mm:ss");
            } catch (Exception e) {
                System.out.println("Erro inesperado: " + e.getMessage());
            }

            teclado.close();
        }
    }

---

## Algoritmo 3: Calculadora de Idade Exata (LocalDate + Period + próximo aniversário)

### Objetivo em passos
1) Ler data de nascimento `dd/MM/yyyy`  
2) Converter para `LocalDate`  
3) Calcular `Period.between(nascimento, hoje)` → anos, meses, dias  
4) Calcular o próximo aniversário:
   - cria uma data com o ano atual e o mesmo mês/dia do nascimento
   - se essa data já passou, soma 1 ano
5) Calcular quantos dias faltam:
   - usando `ChronoUnit.DAYS.between(hoje, proximoAniversario)`

### Bibliotecas úteis
- `java.time.temporal.ChronoUnit` para dias entre datas.

### Código base (exemplo completo)
    import java.time.LocalDate;
    import java.time.Period;
    import java.time.format.DateTimeFormatter;
    import java.time.format.DateTimeParseException;
    import java.time.temporal.ChronoUnit;
    import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
            Scanner teclado = new Scanner(System.in);
            DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy");

            try {
                System.out.print("Digite sua data de nascimento (dd/MM/yyyy): ");
                String entrada = teclado.nextLine();

                LocalDate nascimento = LocalDate.parse(entrada, fmt);
                LocalDate hoje = LocalDate.now();

                if (nascimento.isAfter(hoje)) {
                    System.out.println("Data de nascimento inválida (no futuro).");
                    teclado.close();
                    return;
                }

                Period idade = Period.between(nascimento, hoje);

                System.out.println("\nIdade exata:");
                System.out.println("Anos: " + idade.getYears());
                System.out.println("Meses: " + idade.getMonths());
                System.out.println("Dias: " + idade.getDays());

                LocalDate proximoAniversario = LocalDate.of(
                    hoje.getYear(),
                    nascimento.getMonth(),
                    nascimento.getDayOfMonth()
                );

                if (!proximoAniversario.isAfter(hoje)) {
                    proximoAniversario = proximoAniversario.plusYears(1);
                }

                long diasFaltando = ChronoUnit.DAYS.between(hoje, proximoAniversario);

                System.out.println("\nPróximo aniversário: " + proximoAniversario.format(fmt));
                System.out.println("Faltam " + diasFaltando + " dia(s) para o próximo aniversário.");

            } catch (DateTimeParseException e) {
                System.out.println("Formato inválido. Use dd/MM/yyyy (ex: 05/09/2002).");
            } catch (Exception e) {
                System.out.println("Erro inesperado: " + e.getMessage());
            }

            teclado.close();
        }
    }

---

## Dicas rápidas para você não travar

### 1) Validação simples de formato
- Se não bater com `dd/MM/yyyy`, o parse já cai no `catch`.

### 2) Evite Duration negativa (Algoritmo 2)
- Sempre descubra qual é a data mais antiga e use `Duration.between(antiga, recente)`.

### 3) Teste com casos fáceis
- Algoritmo 1: dias = 0, 1, 7, 30
- Algoritmo 2: datas iguais / invertidas
- Algoritmo 3: aniversário hoje / aniversário já passou / data futura (erro)

---

<!-- nav_start -->
---
Anterior: [106 Acrescimo Subtracao](../docs/106_Acrescimo_Subtracao.md) | Proximo: [108 Estruturas Repeticao 2](../docs/108_Estruturas_Repeticao_2.md) | [Voltar ao Indice](../README.md)
<!-- nav_end -->
